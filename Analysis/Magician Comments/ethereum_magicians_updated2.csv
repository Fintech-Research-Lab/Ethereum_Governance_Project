Title,Website,Category,Author,Article Body,Comments,Comment Authors,Replies,Created at,Views,Users,Likes,Links,EIP
EIP-7069: Revamped CALL instructions,https://ethereum-magicians.org/t/eip-7069-revamped-call-instructions/14432,EIPs,axic,"Discussion topic for

Ethereum Improvement Proposals


EIP-7069: Revamped CALL instructions
Introduce CALL2, DELEGATECALL2 and STATICCALL2 with simplified semantics","['<div class=""post"" itemprop=""text"">\n<p>This EIP is related to the project of removing gas observability. I want to raise that the ability to observe “out of gas” errors might be necessary, that it’s not really possible with the current instruction set, and that a solution to this problem might be a good fit for this EIP.</p>\n<p>The issue is that whenever a contract has logic such as “try this call, and if it reverts do this other thing”, due to EIP-150 there is a chance that the transaction originator can force a contract to follow the “catch” path by triggering the subcall to run out of gas while providing enough gas for the rest of execution to continue (perhaps more so with the introduction of MIN_RETAINED_GAS?). An example where this pattern could be used is to call a getter and have a fallback value if the getter is not implemented. Ideally, the contract would be able to specify that if the subcall reverts out of gas it should not continue execution and should revert. With the revamped CALL instructions this is semi-possible, because through the status code you can distinguish explicit revert from out of gas failure. However, the out of gas error can be triggered in a more deeply nested call, and in this case the “failure” information is lost in the outer scopes.</p>\n<p>My proposal is to encode in the status code whether the call or any nested subcall ran out of gas. This would allow detecting that the code is operating without sufficient gas available.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<aside class=""quote no-group quote-modified"" data-post=""5"" data-topic=""14432"" data-username=""petertdavies"">\n<div class=""title"">\n<div class=""quote-controls""></div>\n<img alt="""" class=""avatar"" height=""24"" loading=""lazy"" src=""https://ethereum-magicians.org/letter_avatar_proxy/v4/letter/p/4bbf92/48.png"" width=""24""/> petertdavies:</div>\n<blockquote>\n<blockquote>\n<p>Note: Unlike <code>CALL</code> there is no extra charge for value bearing calls.</p>\n</blockquote>\n<p>What is the justification for this?</p>\n</blockquote>\n</aside>\n<p>We have added a charge for calls with value, thank you for bringing this up <a class=""inline-onebox"" href=""https://github.com/ethereum/EIPs/pull/7220"" rel=""noopener nofollow ugc"">Update EIP-7069: Add charge for value-bearing calls by gumb0 · Pull Request #7220 · ethereum/EIPs · GitHub</a></p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>So the “revert state” <strong>does not</strong> include e.g. <code>INVALID</code> (0xfe) and exceptional reverts due to e.g. missing jumpdest, insufficient stack args, out-of-bounds returndatacopy?</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>Historical context: these reworked <code>CALL</code> instructions were discussed starting late December when certain unobservability properties were required from EOF. The basic specification was discussed in January and until now kept in the “EOF mega spec”:</p><aside class=""onebox allowlistedgeneric"" data-onebox-src=""https://notes.ethereum.org/@ipsilon/mega-eof-specification"">\n<header class=""source"">\n<img class=""site-icon"" height=""134"" src=""https://ethereum-magicians.org/uploads/default/original/2X/8/8f0a562a90992dd656ced3f9b9b37c942cfbde54.png"" width=""134""/>\n<a href=""https://notes.ethereum.org/@ipsilon/mega-eof-specification"" rel=""noopener nofollow ugc"" target=""_blank"">HackMD</a>\n</header>\n<article class=""onebox-body"">\n<h3><a href=""https://notes.ethereum.org/@ipsilon/mega-eof-specification"" rel=""noopener nofollow ugc"" target=""_blank"">""Mega EOF Endgame"" Specification - HackMD</a></h3>\n<p># ""Mega EOF Endgame"" Specification  [toc]  ## Preface  **This document describes all the changes whi</p>\n</article>\n<div class=""onebox-metadata"">\n</div>\n<div style=""clear: both""></div>\n</aside>\n<p>Creating the EIP is the next step, especially as it is not strictly dependant on EOF.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<blockquote>\n<p>Note: Unlike <code>CALL</code> there is no extra charge for value bearing calls.</p>\n</blockquote>\n<p>What is the justification for this?</p>\n<p>Currently the cheapest way to change a value in a MPT is by modifying a storage key. This costs 5000 gas, leading to a theoretical limit 6000 MPT writes per block under current gas limits. Under this EIP, using the <code>CALL</code> opcode you can modify the balance of an account for only 2600 gas, raising the theoretical limit to 11538 MPT writes per block.</p>\n<p>MPT writes are likely to be expensive. Each MPT write incurs multiple database writes (due to a trie node updates) compared to a singe database read for an MPT read. Charging the same for a read and a write seems questionable.</p>\n<p>I agree with <a class=""mention"" href=""/u/philogy"">@Philogy</a> that non-malicious code overpays for value carrying calls in practice, but I’m concerned this might be DOS vector.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p><code>revert</code> is only returned if the callee uses the <code>REVERT</code> instruction. Should clarify it.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>Because the proposed instructions remove the output buffer, I think this proposal needs to include a <code>RETURNDATALOAD</code> instruction to be complete.</p>\n<p>Here’s why: to replicate current <code>CALL</code> semantics, you need to add extra instructions to copy from returndata into an output buffer (which, I think the best you could do is <code>returndatacopy output_buffer 0 (min returndatasize buf_size)</code> – the best implementation I have for <code>min</code> here is something like <code>push2&lt;buf_size&gt; returndatasize dup2 xor push2 &lt;buf_size&gt; returndatasize lt push2&lt;buf_size&gt; mul xor</code>). Currently, copying into memory is important because it improves the performance of ABI decoding.</p>\n<p>Introducing <code>RETURNDATALOAD</code> allows for (efficient) ABI decoding directly from the returned data and would solve the above concerns because we can skip copying to memory, also allowing us to skip returndatasize checks on account of the OOB semantics of <code>RETURNDATACOPY</code>/<code>RETURNDATALOAD</code>.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>HELL YES FINALLY</p>\n<blockquote>\n<p>It is also useful to have these as new opcodes instead of modifying the exiting CALL series inside of EOF. This creates an “escape hatch” in case gas observability needs to be restored to EOF contracts. This is done by adding the GAS and original CALL series opcodes to the valid EOF opcode list.</p>\n</blockquote>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>Reading the EIP, it’s unclear how “failure” of a call is defined. I assume “failure” is when the call can’t be initiated due to the contract’s <code>balance &lt; value</code> or there being insufficient remaining gas? Are there any other constellations that would constitute a “failure” pushing the status code <code>2</code> onto the stack? An exceptional revert in the call context would still be considered a “revert” and not a “failure”, right?</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>Correct, all these cases result with status code 2 on stack.</p>\n</div>']","{1: 'axic', 2: 'Philogy', 3: 'axic', 4: 'axic', 5: 'petertdavies', 6: 'Philogy', 7: 'gumb0', 8: 'sbacha', 9: 'charles-cooper', 10: 'frangio', 11: 'gumb0'}",10,"May 25, 2023 9:06 am",1383,7,3,4,7069
EIP-7053: Interoperable Digital Media Indexing,https://ethereum-magicians.org/t/eip-7053-interoperable-digital-media-indexing/14394,EIPs,bofuchen,"This EIP proposes an interoperable indexing strategy designed to enhance the organization and retrieval of digital media information across multiple smart contracts and EVM-compatible blockchains. This system enhances the traceability and verification of cross-contract and cross-chain data, facilitating a more efficient discovery of storage locations and crucial information related to media assets. The major purpose is to foster an integrated digital media environment on the blockchain.

Motivation
Given the significant role digital media files play on the Internet, it’s crucial to have a robust and efficient method for indexing immutable information. Existing systems encounter challenges due to the absence of a universal, interoperable identifier for digital media content. This leads to fragmentation and complications in retrieving metadata, storage information, or the provenance of specific media assets. The issues become increasingly critical as the volume of digital media continues to expand.
The motivation behind this EIP is to establish a standardized, decentralized, and interoperable approach to index digital media across EVM-compatible networks. By integrating Decentralized Content Identifiers (CIDs), such as IPFS CID, and Commit events, this EIP puts forward a mechanism enabling unique identification and indexing of each digital media file. Moreover, this system suggests a way for users to access a complete history of data associated with digital media assets, from creation to the current status. This full view enhances transparency, thereby providing users with the necessary information for future interactions with digital media.

For the complete draft, please refer to the pull request. Thanks!","['<div class=""post"" itemprop=""text"">\n<p>While your proposal primarily focuses on digital media, the underlying indexing mechanism and event-driven approach could potentially be extended to other types of assets beyond media files, enhancing its versatility.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>A unique Decentralized Content Identifier (CID) plays a crucial role in facilitating easy tracing of the same asset. CIDs serve as unique identifiers that enable efficient tracking and retrieval of decentralized content. By utilizing CIDs, it becomes simpler to identify and locate specific assets within decentralized systems, promoting transparency, reliability, and interoperability. These identifiers enhance the traceability and verifiability of assets, ensuring that they can be securely managed and validated across various platforms and networks.</p>\n</div>', '<div class=""post"" itemprop=""text"">\n<p>Good stuff.</p>\n<p>This can be super helpful to index the digital media and offer a better approach to digital media provenance, especially for the current generative AI era having such digital cluttering.</p>\n</div>']","{1: 'bofuchen', 2: 'pinglin', 3: 'olgahaha', 4: 'Mani-T'}",3,"May 22, 2023 11:04 am",1085,4,5,1,7053
